= 深度探索C++对象模型
:toc:
:toc-title: 目录

[quote,Ryu613]
我会把lippman或侯捷的核心观点，以quote方式给出（注意这些话不是他本人所说，而是我个人为了阅读效果写的）

====
此书经本人试看后，觉得并不满意，其上位替代是《C++新经典：对象模型》，故暂停更新
====

== 前言

lippman解释了本书创作动机，有二：

. 希望中高级程序员能通过了解C++底层实现模型，写出效率更高的代码
. 消除某些人对于C++的错误认识, 比如C++性能不如C

然后对本书的陈述和组织方式进行了说明，目前阶段可不用关注

=== 导读

侯捷认为，本书是给C++老手看的，需要精读才会有效，略读无效。

本书可以不按章节顺序阅读，推荐阅读1，3，4章，其他章节按需选读

> 我不会完全按照原文的表述总结，尽量转译为更自然的表达

== 第一章 对象

[关键词]
====
关键词:

**ADT(abstract data type)**: ADT = 数据成员 + 操作， 面向对象里的类可以是ADT也可以不是ADT(只有其中一种声明),ADT一般不支持继承和多态

**class**: 称为"类"，但是由于是一个字，本文为了表述不带歧义，本文直接用class

**object**: 称为"对象"，这里不单指面向对象里的对象，也指ADT范式里的对象，本文就叫对象
====

C语言里，数据和函数是分开声明的，没有直接的关系，可以用调用或者宏把二者关联。但是C++不仅可实现C的写法，还可以把数据和函数封装在一起，还支持继承，和模板化

[quote,Lippman]
那些说C比C++更快更简单的人，我告诉你们, 这可不一定！

=== 封装的布局成本

lippman认为C++里对对象的封装并没有增加成本，class里的数据成员是包含在每个class的对象里的，跟C的结构体是一样的，成员函数除非是inline的(会在class的每个对象里)，否则只会在class的声明里存在，不在对象里存在

[quote,Lippman]
C++里对数据和函数的封装行为，在对象的布局上，实际并没有增加额外的成本，只有需要支持虚函数和虚基类时，有额外成本

* 虚函数的成本: 是因为要支持“运行期绑定”的功能
* 虚基类的成本: 是因为要用其实现"多个派生类共享一个基类实例"的功能
* 多继承的成本: 发生在派生类和基类之间的转换过程

=== 简单的对象模型

C++里有2种数据成员： static/非static
3种成员函数： static/非static/virtual

一个class的对象，基本的建模如下：

* class生成对象时，这个对象是看作一系列连续的slots组成，每个slot对应一个这个类里声明的一个函数或者成员
* slot的顺序是按照成员在声明时从上至下的顺序对应
* 这个slot的值，实际上一个指针，指向对应成员的实际值，这么做是为了节省存储成员对应类型造成的存储空间开销

那么这个类的对象的大小，就是： 指针大小 * 成员的数量

在“指向成员的指针”这个功能上，应用了此模型，编译器的具体实现并不是此模型

> 我个人称为"槽位+指针"对象模型或简单对象模型

=== 基于表格的对象模型

建模如下:
* 把class分为两个表，数据成员表和函数成员表,分别存放数据成员和函数成员
* class的对象有指向这两个表的指针
* 函数成员表里由一系列slots组成,每个slot指向一个函数成员(指针)，数据成员表里则是数据成员本身(不是指针)

在虚函数的实现里，参考了此模型
侯捷也提到，在CORBA ORB和SOM里使用了此模型

> 我个人称为“双表”对象模型

=== C++ 对象模型

C++的对象模型最开始是基于简单对象模型改造出来的，改造目的是优化内存占用和存取时间，与简单对象模型的不同点如下:

* 非static的数据成员直接放在每个class的对象里
* static数据成员，和函数成员(无论是否static)，是存在对象外的
* 虚函数功能的支持实现如下:
** class里的每个虚函数对应一个虚函数指针，放在一个表里，这个表叫虚表(vtbl)
** 此class的每个对象会有指向vtbl的指针，这个指针叫虚表指针(vptr),vptr的设置和重置操作是由构造函数，析构函数，和拷贝赋值运算符自动完成的
** 每个class对应支持RTTI的类型信息对象(type_info object)的指针，放在vtbl的第一个slot

==== 对继承的支持

[关键字]
====
**subobject**: 指派生类对应的基类的实例,放到了派生类的对象里,作为其下属的对象
====

C++支持单继承，多继承，虚继承，虚继承就是指基类只有一个实例，那么非虚继承就是派生类各自有各自的基类实例

如果用简单对象模型实现，可以在派生类的slot记录一个指针，指向基类的subobject，这种方式由于要记录一个指针，并且随着继承层数增多，存取基类所需的取指针次数就变多，所以在空间占用和存取上更麻烦，优点是若基类改变，不会导致这个派生类的对象大小也会改变。

或者发明一个基类表(bptr),类似虚表那样，存每个基类的地址。这种实现方法的优缺点：

* 优点
. 所有class的对象里，都有一个基类表，即对于继承的实现都一致，更容易理解
. 基类表的改变不会改变这个类的对象本身
* 缺点
. 空间占用，每个对象都要有一个基类表
. 存取麻烦：若继承的层数多，要多次用指针取基类，增加了存取所需次数，影响存取效率

在最初的C++对象模型里，不是如上文这么做的，而是把基类subobject的数据成员直接放在派生类的对象里，方便了派生类访问基类的数据成员，但是会导致若基类成员变化，这个基类和所有派生类都要重新编译

在C++2.0(据查是89年完成的)引入了虚基类(virtual base class)，原本的实现是为每个关联的虚基类加一个指针

其他演化出来的模型，要么加一个虚基类的表，要么在已有的虚表上记录虚基类的指针

==== 对象模型对程序的影响

不同的对象模型，会导致现有程序代码需要修改和新增

=== 关键字的差异

C++与C在关键字上差异性和复杂性主要是由于前者需要兼容C的语法导致的

[quote,Lippman]
====
C++复杂？还不是因为要兼容C语言的语法!
我老早(1986年)就想把C++与C的语法做隔离了！奈何贝尔实验室里有人不同意！class和struct的问题烦了我多少年？！
====

C++里同一个访问级别下的数据，在内存布局里也是按声明顺序排列的，但是这些访问级别整个的顺序，是不一定的

==== 原则上正确的构造体

某些利用struct取巧的做法，在C++未必能保证可行，lippman建议别那么做，例子看不大懂，先略

=== 对象的差异

C++支持三种程序设计范式：
. 程序模型: 就是C的写法
. 抽象数据类型模型: 就是前文所述的ADT对应的模型，没有继承，多态
. 面向对象模型：你懂的，后文称为OO paradigm

虽然C++支持以上三种编程范式，但是只用一种范式来编写程序，才不容易出问题, 不推荐混写范式

书中列举了一个例子，某个派生类被隐式强转为父类，导致类型裁剪，从而导致调用函数时调用的是父类的而不是自类，多态性失效

> C++实际场景还是以OO paradigm来写就行了，非必须没必要以前两种范式写程序

==== C++中如何实现多态

. 把指针从派生类类型转为基类类型后，可以支持多态:
. 用虚函数
. 用dynamic_cast和typeid运算符支持

[source,C++]
----
shape *ps = new circle(); // 把circle类型的指针转为基类的指针
ps->rotate(); // 通过虚函数，最终调用的是circle的rotate()
if(circle* pc = dynamic_cast<circle*>(ps)) // 为true时代表ps指针可被转化为circle类型的指针，并赋值给pc
----

class的对象要多少内存？

类对象需要的内存 = 非static数据成员的总大小 + 内存对齐和填充大小 + virtual需要的内存大小

==== 指针的类型

指针本身是一样的，都是一个内存地址，指针的占用空间在32位系统里是4字节(32位),在64位系统里是8字节(64位)

指针的类型来自于指向的对象的类型，用来告诉编译器这个指针指向的地址中的内容和大小是什么，若指针是void*,则该指针不知道如何操作指针指向的内容，可以推导出，转换指令并不会改变指针，只影响如何解读这个指针指向的内存是什么和多大

就是说，比如有一个类ZooAnimal, 派生了Bear类，那么若:

[source,C++]
----
Bear b;
ZooAnimal* pz = &b; // 指针只能操作Bear里的subobject(即ZooAnimal的部分)，可通过虚函数，处理Bear的成员
Bear *pb = &b; // 不仅可以操作Bear的subobject，还能操作Bear里的部分
----

> 少用C式类型转换，如(B)A;
> 由于性能原因，static_cast使用优先级应大于dynamic_cast,但是static_cast只能向上转换，是在编译器确定类型，dynamic_cast可以上下转换，是在运行时确定类型

两个问题：

. 为什么拷贝赋值后作为基类的对象，不能调用被拷贝的派生类的函数？
    答： 基类和派生类初始化时，所占的内存和地址就是确定好的，强行把派生类类型赋值给基类，由于基类所占的大小早已固定，派生类的大小又大于基类，所以会把派生类多出来的部分切割舍弃，只留下基类subobject的部分，所以没有了多态性
. 如果赋值时对应的构造函数是将一个对象完整拷贝到另一个对象，拷贝后的新对象的vptr为什么不是指向原对象的vtbl?
    答： 是因为编译器要进行拷贝赋值操作时，要确保带有虚指针的对象里，这些虚指针的值，都不能被原对象初始化或改变

> 若要使用多态，就需要用指针或引用，不能直接用对象，这是因为指针或引用只会改变如何解释所指向的内容和大小，不会改变内容，而对象的拷贝赋值操作，会改变内容，但是由于初始化时基类所占用的内存大小已经确定没法更改，所以派生类会只取基类subobject的部分，把其他部分切除抛弃，所以失去了多态性

ADT范式(也叫OB(object-based(基于对象)))的优点：

不可继承，不支持多态，故没有虚表和虚指针，调用速度快(所有函数调用在编译期就可确定)，数据紧凑(不需要设置虚表和虚指针)，但是不太灵活。

选择OO还是OB视情况而定

== 第二章 构造函数的语意

== 第三章 数据的语意

== 第四章 函数的语意