= 第五章 类和类的层次结构

== C.1 把相关的数据组织到struct或class中

比如一个函数具有多个入参，可以把参数封装成可读性更好的struct或class，同时参数数量也更少

== C.2 若类具有不变式，则用class，反之，则用struct

是关于如何选择struct还是class的方法，就根据参数之间是否可以独立变化，若可以则struct，反之则class

不变式个人理解： 无规矩不成方圆，有恒定规矩的事物，因其规矩才成为一体，相关的元素放在class，否则放在struct

通俗来讲，struct里的元素可以独立变化互不影响，只是把他们绑在一起而已，而class里的元素，它们之间可能有某些固定不变的规则才使其成为一种事物

== C.3 在类中体现出接口和实现的区别

类的public成员函数应该是类的接口，而实现应该放在private里，这样，不会影响此类的用户

== C.4 仅当函数需要直接访问类的内部时，才把其变成成员

也就是如何判断一个函数是否应该是成员函数的办法，就是看这个函数是否要直接访问到类的内部数据，好处是松耦合

== C.5 将辅助函数与它们所支持的类放在同一个namespace中

== C.7 不要在一条语句里同时定义和声明该类型的变量

如 struct A{...} a{...}; 应该避免,分成两条写，防止疑惑

== C.8 若有任何private成员，就用class而不是struct

因为需要构造函数来保证不变式，故应使用class更好

== C.9 尽量减少成员的暴露

不用多说

== C.10 优先使用具体类型而不是类层次

更简单，性能开销小，具体类型就是指单个具体的类，即值类型的类

== C.11 让具体类型规范化

规范类型： 类似int，必须支持拷贝，赋值，相等比较，可交换，析构，移动，默认构造操作

主要是易于理解和使用

== C.20 如果能避免定义拷贝，移动，析构函数，那就这么做

是说如果类的成员都支持移动，拷贝构造，阿么就尽量不要自己写这个类的移动，拷贝构造等函数

== C.21 如果delete了任意拷贝，移动，析构函数，就对所有这些函数都手动定义或delete

就是只要出现delete了任意一种构造,析构函数，就需要显式将其他几种函数都default或手动定义

== C.22 让拷贝，移动，析构函数的操作保持一致

防止类的用户产生疑惑

== C.45 不要定义只用来初始化成员的默认构造函数，而是用成员初始化器替代

就是在默认构造函数里给成员赋默认值，这么做不好，改成在成员写上默认值(用大括号)，然后默认构造器保持default

这样更容易维护构造器的逻辑，如果以后修改或添加新的成员，不用每次都更改默认构造函数的逻辑

== C.46 单参数的构造函数声明为explicit

不用多说

== C.47 按照成员声明的顺序定义和初始化成员列表

要注意，类的成员的实际初始化顺序取决于声明的顺序，而不是初始化列表的顺序,析构则是按声明顺序相反的顺序进行

