= 第一部分 要习惯{cpp}

== 1. 把{cpp}视为由多种语言组成的联盟
为什么这么想?::
C++也是随着编程技术发展的，由于代码的编程范式不断演进和多样化，{cpp}也对下列五种范式提供了支持:
* 过程化范式
* 函数化范式
* 对象化范式
* 泛型化范式
* 元编程范式

每种范式的编程方法和约定不同，故{cpp}也没有统一的写法和规范，你要习惯于此

> . 整体上来说，新的范式都是对之前范式的再次抽象，越新的范式抽象层次越高，也越不容易理解
> . 对象化范式是{cpp}目前主要的范式，过程或函数化范式多见于纯C语言的老项目, {cpp}中经常也会有见到，泛型和元编程一般只在有限场景下使用，要避免滥用，因为可读性和维护性相对对象化范式要低一些
> . 如果你的工作环境有约定，按约定执行，如果没有，我推荐参考你要编码的项目而定，不要鲁莽和随意的在已有项目里引入新的范式，多与项目组其他成员沟通

== 2. 尽量用const/enum/inline替换掉#define
为什么?::
#define有以下缺点:
. **调试困难**: 值是由预编译器替换的，早于编译器处理，导致编译器只知道这个值，不知道对应的是哪个名字的宏定义，如果有问题要排查时，可能难以追溯和调试
. **没有作用域导致参数污染**: 一旦引入，下文皆有效，除非#undef
. **易出错，难理解**: 宏函数多或者嵌套，读起来费劲，也就容易出错

怎么做？::
. 对于常量，用const或enums替换
. 对于宏函数，改用inline函数

> 宏也有其适用的场景，没必要完全禁止，但是尽量少用，而且宏要尽量简单且易于理解

== 3. 尽量多用const
为什么?::
. 避免误操作导致变量被错误修改
. 利用编译器的const特性，方便检查代码错误
. 函数里根据不同场景声明const，可提高函数具体的操作行为，提高代码健壮性

如何做?::
. 声明函数时，考虑三种场景:
* 若返回值不能修改，在函数代码前加const
* 若函数入参不会被修改，函数的这个形参声明加const
* 若是成员函数，其不会更改这个类的成员，则在函数代码末尾加const
[NOTE]
====
* 函数末尾const要注意:
. 若成员变量是指针，即便函数声明是const，仍然可以更改这个指针所指向的内容
. 为某成员声明为mutable，可允许此函数修改此成员
====

小窍门::
. 当有常量和非常量两个版本的函数有实质等价的实现时，用非常量版本的函数调用常量版本的函数可避免重复编码，只需要用const_cast和static_cast处理常量转换和类型转换即可，但是不要用常量版本去调用非常量版本

> 真实项目要看情况，如果是你负责某个新写出来的函数的设计和实现，考虑清楚后，优先加const没问题，如果你去改已有的函数，特别是有诸多调用依赖的函数，要谨慎

== 4. 使用对象前，要确保此对象初始化已完成
为什么?::
. 对于基础类型，C++不保证初始化它们，而这会导致不可控
. 尽量用构造函数的初始化列表来初始化，除非必要，不在函数体里面赋值
* 成员变量的初始化是早于构造函数的调用的，故在构造函数里面赋值，严格来讲不是初始化
* 整体来看，在初始化列表初始化，效率高于构造函数里面赋值，因为少了一次赋值操作(没有显式构造，实际上也有一次赋值，而写到构造函数里，相当于赋值两次)
. 成员在类里的声明顺序，要与构造函数成员初始化列表的顺序一致，这是为了提高可读性
* 注意，没在构造初始化列表写出来的成员，实际也会初始化

如何做::
. C++11及以上版本中，对于基础类型，可以直接在类成员声明时赋值
. 基础类型以外的类型，确保在构造函数初始化时把所有成员都处理
. 对于成员变量繁多，初始化和赋值操作差异不大的成员，可以写到构造函数里面
. 如果有多个构造器有相同的代码，可以提取成private函数，让这些构造函数统一调用此函数
. 对于某些不在函数里面的static对象(即non-local static oject), 跨文件时注意依赖关系，{cpp}没法保证这些对象的初始化顺序
* 解决办法是可以把这些对象搬到函数里面，也就是把non-local给local化，这样就可以保证只有在函数被首次调用时，才被初始化