= 第四章 函数

== F4: 如果函数可在编译期求值，可声明为constexpr

* 性能好
* 线程安全
* 隐式inline

== F6: 若函数必不会抛出异常，声明为noexcept

== F7: 优先使用纯函数

就是参数相同时，返回结果相同的函数，方便：

* 独立测试
* 方便缓存结
* 支持自动重排，或在其他线程执行

== F15: 优先采用简单且约定俗成的函数参数传递方式

* 基础类型传类型，不可更改写const，自定义类型优先const A&, 参数可被改则A&, 要移动入内则A&&

== F16: 入参拷贝开销低，则按值传递，反之用const A& 传递

若sizeof(A) <= 2 * sizeof(void*)则按值传递A，反之则按const引用传递

== F19: 需要转发的参数，用右值传递并只std::forward该参数

可以保证这个参数的左值和右值是原封不动的，语义不会变化

== F20: 输出的参数值优先用返回值，而不是用一个入参表示

{cpp}17有NRVO优化不必要的拷贝操作

== F21: 若函数要返回多个值，优先考虑返回struct或std::tuple

可用std::tie或结构化绑定解包返回的参数

== F42: 返回T* 只用于表示位置

== F44: 若不希望拷贝，也不需要表达“没有返回值”时，应返回T&

返回引用可避免对象拷贝，同时不能为null

== F45: 不要返回T&&

右值还能返回？啥场景？

== F48: 不要返回std::move(局部变量)

由于有RVO，NRVO，return std::move()实际上是对性能的劣化

== F50,52,53

关于lambda的，以后再看

== F51: 优先采用默认参数，而不是重载

如果一个函数有多个重载，优先选择带有默认参数的那个

== F55: 不要用va_arg

就是省略号参数，用变参模板替代，即T..., 用折叠表达式可自动忒大参数数量和类型，不容易出错

====
本章主要就是讲函数的名字，参数的类型，返回值类型相关的选取建议，大部分都知道，lambda的内容之后补充
====