# C++新经典

## C++介绍

### 历史

1. 在PDP-11/20大型机上，由Ken Thompson发明了B语言,并开发了UNIX系统
2. 由于B语言过于简单，1972-1973年间，由Ritchie在B语言基础上设计了C语言，之后与Ken合作用C重写了UNIX
3. C语言特点：一般只比汇编代码效率低10-20%，语言灵活，可写软件
4. 1998年，由C++标准委员会发布第一个C++标准，人称C++98

## 对象的大小

1. 对象的大小=类的大小+对象的大小，类的大小取决于类的成员定义
1. 类声明后，至少占用1 byte，类的成员函数，不占用类对象的内存空间

    ```c++
    A a; // A为没有任何成员的空类
    sizeof(a); // 为1
    ```

1. 类的成员变量会占有类对象的内存空间
1. 若成员为静态，不占有类对象的内存空间
1. 成员函数无论是否static，都不占用类对象的内存空间
1. 若有虚函数，，不论有几个，会导致类(不是其对象实例)增加4 byte，这4byte就是一个指针，这种指针叫虚函数表指针(vptr), 指针指向虚函数表,这个表会保存在生成后的可执行文件中，执行程序时会把这个表载入到内存。这个指针的值的赋值和重置等操作，由系统内部控制，一般是在构造，析构，拷贝赋值等运算时会操作指针的值
1. 当类中有多个成员变量，某些编译器会优化，做内存字节对齐

    ```c++
        char a; // 1byte
        int b; // 4byte
    ```

    上面代码的类，在某些编译器下不是占5byte，由于两个成员变量紧邻，故把char分配了4byte，变为4+4=8byte

1. 指针无论类型，占用的内存大小是固定的，若为32位，占用4字节，64位占用8字节

## 类对象的大小

类对象大小 = 非static成员变量所占的内存总量 + (虚函数表指针(4byte(32)或8byte(64)))+ 内存字节对齐

若有多重继承，且每个父类都有虚函数，情况会不同，见下文

## 继承类的指针地址会根据函数的调用改变

1. 若是单继承，派生类对象的this对应的内存地址与基类this的内存地址相同，若是多重继承，则派生类是第一个基类的this内存地址，而后续基类的内存地址正好相差了第一个基类所占的类空间大小
    即是说，派生类调用函数时的this地址，根据这个函数对应的基类的this的地址而定

## 编译器只在必要时自动生成默认构造函数

1. 该类没有构造函数，且包含一个成员变量，这个成员是类类型，并且这个类含有默认构造函数
    这些成员的初始化顺序基于声明的顺序依次进行
1. 基类具有默认构造函数，派生类没有构造函数
1. 一个类含有虚函数，且该类没有构造函数
    因为要在类实例化时，把虚函数表指针指向虚函数表的地址，故编译器会合成默认构造函数
1. 虚基类，即有一基类A，两个类A1,A2都继承A，B同时继承A1,A2,理论上B应该包含两个A类的，但是实际上，只会包含一个A，这种情况的A类就叫做虚基类
    - 继承声明是这样的: class A1 : virtual public A{}; // 若继承自虚基类A，要有virtual
    - 虚基类也对应一个表，叫虚基类表
    - 带有虚基类的类，会生成默认构造函数
1. 定义成员变量的时候赋了初值(C++11及以上支持)时，若没有默认构造函数，编译器也会合成构造函数

## 拷贝构造函数

与默认构造函数一样，编译器只在必要的时候会合成拷贝构造函数。

若类的成员是简单的数据类型，比如int，或者是类类型，这个类的成员也是简单的数据类型，则不会生成拷贝构造函数，而是直接递归地采用按值拷贝的方式赋值。

会生成拷贝构造函数的情况：

- 若某个类A不含拷贝构造函数，但成员中有一个类类型B，此类含有拷贝构造函数，这时A会生成拷贝构造函数
- 若派生类不含拷贝构造函数，但是基类有，会为此派生类生成拷贝构造函数
- 若派生类不含拷贝构造函数，但是该类，或其基类有虚函数
- 若某个类不含拷贝构造函数，但是此类含有虚基类

## 移动构造函数

也是只在必要时生成，情况如下:

- 若某个类已有自己的拷贝构造，拷贝赋值，析构函数之一，便不会生成
- 没定义拷贝构造函数，拷贝赋值运算，析构函数之一，并且每个非static成员都可移动，便会生成移动构造或移动赋值运算符

    成员可以移动的条件如下:
  - 内置类型(如整型，实数型)
  - 类类型，且有移动操作相关的函数

## 程序转换语义

编译器处理代码时，会把这些代码拆分成更容易理解和实现的代码