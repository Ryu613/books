# 第一章 vulkan总览

## 介绍

1. 支持vk的设备一般包括一个处理器和多个固定功能的硬件区块，用来在图形和计算中进行操作加速。设备中的处理器一般有非常多的线程，故在Vulkan里的计算模型重度依赖并行计算。
2. vulkan的设备也可访问内存，且暴露这些内存给开发者。但是这些内存不一定与你用来运行程序的处理器共享。
3. Vulkan的API都是显式的，就是说基本所有操作都由开发者自己负责。
4. 驱动就是一种软件，这种软件把指令和数据形成API，并且把它们转换为某种硬件能理解的形式
5. 传统的API比如OpenGL会帮你检查程序错误，对象状态，管理内存，和同步数据等，比较消耗CPU时间。但是Vulkan把这些工作交给开发者负责，并且把错误检查委托给**层(layer)**了，还得手动设置为启用才生效。
6. Vulkan程序啰嗦且脆弱，但是自由度更高，对设备的操作也可以更细致，可达到的性能上限高
7. Vulkan的设计不仅是作为图形API，其功能被拆分成各种子类别，比如用于拷贝数据的传输类别，用于运行着色器的计算类别，还有图形类别，其包括了栅格化，图元组装，混色，深度，模板测试等常见图形功能。设备对于每个模块的支持都是可选的，甚至呈现层(把图片展示在显示设备上)都是可选的，不在Vulkan的核心API里，而是其扩展里的一部分

## 实例，设备，队列

1. vulkan包含了一个功能上的层次结构，最高层级是**实例(instance)**,实例整合了所有支持vulkan的**设备(device)**，每个设备暴露一个或多个**队列(queue)**。队列是用来执行你程序要做的事务的。
2. 实例是一种逻辑上的软件结构，通过你应用里的上下文，来区分你自己的应用和其他应用或库的状态。
3. **物理设备**是实例的成员，每个设备有确切的能力，也包括可选择的队列。一般来说，物理设备(除了支持热插拔的设备外)代表固定且有限数量的单个硬件，或者一组相互连接的硬件。
4. **逻辑设备**是被实例创建出来的，是基于物理设备构造的一种软件结构，用来代表特定物理设备所保留的某些资源。可能包括可选队列中的一部分。一个物理设备可以创建多个逻辑设备，应用里大部分时间都是都是与逻辑设备进行交互的。

![vulkan层级](img/vulkan-hierarchy.png)

此图展示了vulkan的层次架构，注意到几个点：

1. 物理设备不一定归属于单个实例
2. 一个应用可以有多个实例
3. 逻辑设备都是归属于单个物理设备的
4. 队列都是归属于单个逻辑设备的

初始化vulkan时，就是从上往下依次创建

## Vulkan实例

1. vulkan可看作你应用的一个子系统。vulkan的内部状态都存储到了你提供的某个对象里，这个对象就叫instance，对应VkInstance对象。创建实例通过调用vkCreateInstance()
2. vulkan是用结构体传参的，结构体里面都有一个sType,这个参数决定了你传的是哪种类型，不同的vulkan对象对应不同的sType

## Vulkan物理设备

vulkan有两种设备，物理设备和逻辑设备，物理设备对应真实硬件设备，一般是固定数量且能力也是固定的。逻辑设备是物理设备的抽象，一般应用的大部分操作都是对逻辑设备进行。在创建逻辑设备之前，需要先列举已连接的物理设备，通过调用vkEnumeratePhysicalDevices()函数实现

## 物理设备的内存

在vulkan中，设备内存是指可访问的设备中，可用于存储纹理和其他数据的内存，这些内存的类型用types字段区分，每种类型有多个属性，比如缓存标识，宿主和设备的关联行为等。每种类型的内存之后会由设备的堆支持，设备可能有多个堆。要查询堆的配置和设备支持的内存类型，可通过调用vkGetPhysicalDeviceMemoryProperties()完成

## 设备的队列

1. vulkan的设备会执行提交到队列的任务。一个设备可以有一个或多个队列，每个队列属于某个设备队列家族。队列家族就是一组具有相同能力且可并行运行的队列。关于队列家族的数量，每个家族的能力，每个家族队列的数量，都属于物理设备的属性，要查询这些属性，调用vkGetPhysicalDeviceQueueFamilyProperties()
2. 有可能设备会报告具有同样属性的队列家族，其实质是不同的，只是不同点在内部，vulkan无法通过api表达出不同点

## 创建一个逻辑设备

列举完所有的物理设备，你就应该选择其中一个，然后为其创建逻辑设备。逻辑设备代表设备是处于初始化状态的。通过vkCreateDevice()创建

## 对象类型和函数准则

事实上vulkan里的所有东西都是用对象表示的。这些对象又分为两种列别，可分派和不可分派的。

可分派的对象就是内部包含了一个分派表的对象。这个表里就是各种其他组件会用得到的函数，在调用vulkan时，会决定哪部分代码会被执行。这种类型得对象一般来说构造都比较麻烦，目前包括实例，物理设备，逻辑设备，指令缓冲，队列对象。其他对象都看作不可分派的

传入vulkan得函数里的第一个参数，一定是一个可分派的对象，与创建和初始化instance有关的函数除外

## 内存管理

vulkan提供两种类型的内存：主内存和设备内存，被vulkan API创建的对象一般来说是用主内存，vulkna用这些内存来存储对象的状态和与API实现相关的数据。

类似缓冲，图像等资源对象是用设备内存，这些内存用来存储资源相关的数据

对于vulkan的主内存，可以管理，对于设备内存，必须管理。管理设备内存，需要创建一个设备内存管理的子系统。你创建的每种资源可以查询到数量和类型。这些内存的分配是由你自己决定，并且资源要与对象关联起来才能使用

在OpenGL中，是由驱动控制设备内存的分配，根据使用模式来自适应调整的。但其实资源的大小和数量只有开发者知道，要有更好的内存管理，就需要自己控制。

要重点注意，对活动内存的分配是有性能成本的，因此，对象分配的次数要尽量少。比较推荐的做法是，设备内存分配器应该分配一大块设备内存。许多小的资源可以放在里面很小的内存块里。详见第二章

## vulkan中的多线程

vulkan中的来说是假设了应用会保证不会有两个线程同时操作相同对象，这被称为外部同步性。绝大部分在vulkan中性能影响大的指令都不提供同步性，比如构造指令缓冲等。

为了对各种vulkan指令具体定义对线程的要求，每个参数都需要保证不可并行访问。vulkan内部实现不会用某种互斥或同步性的原语来保证数据结构，主要是为了不会由于多线程程序导致vulkan内部卡死

为了要求宿主跨线程访问共享对象时的同步性，vulkan包含了多种特性，专门用于无阻塞地让线程执行工作

- 主内存的分配是通过传入对象创建函数里的主内存分配结构体来操作，每个线程有自己的分配器，详见第二章
- 指令缓冲是在池里分配的，这个池的访问是通过外部同步的。若应用为每个线程使用各自的指令池，指令缓冲就是在各自的池里操作，互相之间就不会阻塞，详见第三章
- 描述器是以一组的方式分配在描述器池中。描述器表示着色器在设备上用到的资源，详见第六章
- 二级指令缓冲允许一个较大的渲染通路的内容可并行生成，然后当从主指令缓冲调用时，被分成组。二级指令缓冲详见第十三章

若你只开发一个单线程应用，这些倒是没必要，然而，随着应用多线程化，为了性能，这些对象都不可或缺

## 数学概念

## vulkan的加强

除了vulkan自身的api，还通过layer或extension进行扩展。layer可以对vulkan现有特性做出扩展加强，extension为vulkan添加新的功能。

## layer(层)

1. layer可以对vulkan的特性做出更改，层可以在vulkan的各个部分中做横切，然后添加各种功能，比如日志，追踪，诊断，分析等。
2. layer可以在instance的级别添加，这种情况会影响整个vulkan实例，包括其创建的所有设备。layer也可以在设备级别添加，那么layer就只会影响这个设备了
3. 对于系统里vulkan实例支持的layer，通过vkEnumerateInstanceLayerProperties()获取

## extension(扩展)

扩展是vulkan跨平台的基础，如同vulkan本身一样，有公开的API，允许用户做实验和创新，方便发展vulkan。一些有用的特性就是从扩展里添加进未来版本的vulkan中

但是扩展也是有代价的，可能需要对额外的状态和检查做出实现，或者额外的性能开销等。因此，若用不到的话必须显式关闭，以避免额外的性能开销和引入多余的复杂性。

扩展分为两类，instance扩展和设备扩展，实例扩展一般来说是对整个vulkan系统做出加强。设备扩展时对一种或多种设备的能力做出扩展，但是没必要在所有设备都可用

一旦启用扩展，应用就可以使用其API，实例扩展要在vulkan实例创建前启用，设备扩展也同理。查询支持的实例扩展可用vkEnumerateInstanceExtensionProperties()

## 正确关闭vulkan

1. 所有工作应当完成，或者直接中断，包括宿主和设备，所有与vulkan有关的线程，以创建时相反的顺序来销毁对象。
2. 逻辑设备很可能是最后一个要销毁的对象，销毁前，确认没有运行的事务,通过调用vkDeviceWaitIdle()