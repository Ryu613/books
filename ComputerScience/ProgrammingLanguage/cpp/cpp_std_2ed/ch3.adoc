= 第三章 语言新特性

====
有些术语翻译与我之前认识的不一样，不过不影响理解
. scoped: 领域？我叫作用域,这里的过去式应该代表具有,已被作用域化的意思
. by value, by reference: 没看过类似effective {cpp}之类的可能不懂，就是函数传参按值还是按引用传递

个人认为的疏漏点:
. 没有说明lambda mutable时，传入的参数只在内部共享，不会像引用传递那样可以改外部的参数
====

== 重点

. lambda不太熟，在此记录一下
.. [=]: 用值传递的方式把参数传到lambda里面
.. [&]: 用引用传递的方式传参
.. 也可以个别指明，例如: [x, &y]{...}; x是值传递，y是引用传递
.. []() mutable{}; 这里写个mutable，就是说参数可改可不改
.. lambda是个不具名函数对象，如果要表达这个对象，可用auto或std::function表示

== 值得一提

. decltype: 根据变量找出类型，比如只知道变量名不知道类型的场景，有需要根据这个变量的类型声明一个变量，一般用在模板元编程
.. 形如： auto add(T1 x, T2 y) -> decltype(x+y); 是可以的，返回值是根据x+y运算出来的类型决定的,这里返回后置
. 可用模板参数来代表具体参数，形如: bitset<32> flags32; 代表有32bit的bitset,这里的32不是一种类型，而是参数
. 文中又提醒了一下，用大括号明确默认值，声明即初始化是很好的做法

== 待探讨

lambda的mutable使用场景呢?语义是啥::
调用内部的一个共享副本，多次调用下，传入进来的值都是用的同一个副本，区别于值传递下，每个副本都是独立拷贝的一份，区别于引用传递下，会改变外部变量
