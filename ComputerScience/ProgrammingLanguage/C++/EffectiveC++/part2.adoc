= 第二部分 关于构造/析构/赋值操作符

== 5. 要知道C++私底下编写并调用了哪些函数
分场景来看：

. 空类会自动声明以下函数, 都是inline且public的:
* 一个拷贝构造函数
* 一个拷贝赋值操作符
* 一个析构函数
* 一个默认构造函数
. 这些函数只在有调用时，才会由编译器生成
. 如果已有构造函数，则编译器不会再声明默认的无参构造函数

== 6. 显式禁止编译器自动生成你不需要的函数
如何做？::
把相应的成员函数声明为private，并且不写实现

> 比如，不允许栈上分配，可私有化析构函数，不允许拷贝，赋值，可删除对应函数，有些场景会用到

== 7. 若基类要支持多态，则把此基类的析构函数声明为virtual
如何做?::
如果类带有虚函数，就把析构函数加virtual,反之，若这个类以后也不会作为基类，就不用声明虚析构函数

== 8. 析构时，要避免异常抛出
为什么?::
若有意外的异常泄露出去，程序可能产生不明确的行为，导致程序功能被影响甚至破坏
怎么做?::
. 若析构函数中有可能抛出异常，要在其中处理掉，并且不要再次抛出
. 若运行时需要对抛出的异常做处理，应该提供一个普通函数来执行该操作

== 9. 绝对不要在构造或析构时调用虚函数
为什么？::
不会按期望调用到派生类里的对应函数

== 10. 让operator=返回一个*this引用
为什么?::
连续赋值时需要用到这个指针，所以最好实现

== 11. 在operator=中处理"自己赋值自己”的情况
为什么?::
确保自我赋值时，行为是正确的

== 12. 拷贝对象时要把所有对象中的内容都处理到位
如何做?::
. 确保拷贝函数复制了所有对象内的成员，包括基类里面的
. 不要在某个拷贝函数里调用另一个拷贝函数，应该将共同逻辑放到一个新的函数里，由拷贝函数调用，确保逻辑一致性