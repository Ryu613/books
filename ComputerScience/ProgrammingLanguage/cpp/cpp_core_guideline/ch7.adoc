= 第七章 资源管理

== R.1 使用资源句柄和RAII自动进行资源管理

第一条就是RAII，足见其重要性，我已实际应用，略

== R.3 和 R.4 原始指针和引用不表示所有权

一般是搭配R1说的，使用了RAII，所有资源都有了一个所属，这个所属类负责资源的分配和释放，外部调用者如果需要使用，不能对其持有的资源进行修改，就会使用裸指针或引用，一般引用还会加上const限制其对资源"只读"

== R.5 优先使用具有作用域的对象，不做非必要的堆上分配

也就是优先栈上分配，堆上分配的对象要自己管理资源，很容易出资源管理相关的问题

可以花括号显式地指定一个作用域

== R.10 避免malloc()和free()

C的这两个函数只负责分配内存，不负责调用构造/析构函数，会出现未定义行为。此条已知晓，不必细说

== R.11 避免显式调用new和delete

用智能指针替代，析构逻辑可选

== R.12 将显式资源分配的结果立即交给一个管理者对象

也就是说，资源都应当有一个管理者，这个管理者负责资源的分配和销毁，比如用智能指针

这里特地说了"立即",指的就是比如

[source,c++]
----
// 错误例子，uniq1,uniq2都成了myInt的所有者，会造成双重释放引发未定义行为
MyInt* myInt = new MyInt(2011);
std::unique_ptr<MyInt> uniq1 = std::unique_ptr<MyInt>(myInt);
std::unique_ptr<MyInt> uniq2 = std::unique_ptr<MyInt>(myInt);
// 使用make_unique替代
std::unique_ptr<MyInt> uniq = std::make_unique<MyInt>(2011);
----

== R.13 在一条表达式语句中最多进行一次显式资源分配

例如这样的代码:

[source, C++]
----
// 编译器可能会自由决定1,2的内存分配和构造的顺序以优化性能，比如两个对象都先分配内存，再构造
// 如果在某个构造函数抛出异常，可能另一个对象的内存就不会自动释放
func(std::shared_ptr<Widget>(new Widget(1), new Widget(2)));
----

可改用make_shared/make_unique，这两个构造可保证如果有异常抛出，函数调用不会发生副作用

但个人认为构造相关的语句还是分开一条一条写比较好，至于用make_unique， make_shared已是习惯

注意，此问题在17已可保证求值顺序，故不会导致内存泄漏

== R.20 用unique_ptr和shared_ptr表示所有权

已知晓，略

== R.21 除非需要共享所有权，否则能用unique_ptr就别用shared_ptr

略

== R.22 和R.23 用make_shared, make_unique

略

== R.24 用std::weak_ptr打破shared_ptr形成的依赖循环

主要会导致互相引用造成不被释放(引用计数始终不为0)

例子中值得注意的是，会形成循环依赖的基类成员用weak_ptr, 此成员的类的成员用shared_ptr

还是想说能用unique_ptr就用，少用shared_ptr,所有资源有唯一一个所有者更好，shared_ptr这东西不单容易循环依赖,而且性能上也不如unique_ptr(引用计数开销，高性能应用要避免)

== R.30 只在显式表达生存期语义时以智能指针作为参数

就是传参一般只用裸指针或const引用，除非涉及到资源生存期变化的操作

如果传入智能指针，一般来说语义是此函数会改变所有权（或成为所有者之一(shared)），传入引用类型的智能指针，则代表此函数会对此指针拥有的资源进行重设(reset)

== R.37 不要传递从智能指针别名中获得的指针或引用

看了例子，需要注意如果shared_ptr是用引用传递的，不会增加引用计数，这可能会导致后续引用如果消失造成悬空指针

unique_ptr也是，但是不能通过拷贝来增加计数

如果是使用了此指针的资源，若是shared，则函数以值传递，若是unique,则用裸指针传递比较好

====
本章主要讲了2个东西:

* RAII
* 智能指针的使用

大多已知晓，但是使用时还是得多注意，用不好还是会有内存泄漏和悬空指针问题，主要是把所有权和生存周期意识加强
====
