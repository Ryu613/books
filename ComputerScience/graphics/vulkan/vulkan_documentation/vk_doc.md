# Vulkan官方文档 个人总结整理

不是全文翻译，根据章节部分翻译，部分总结

> 地址：https://docs.vulkan.org/spec/latest/chapters/fundamentals.html

## 基础

本章会介绍基础理念，包括Vulkan的架构和执行模型，API语法，管线配置，数值表示，状态和状态查询，不同类型的对象和着色器。"特性"部分的剩余部分提供了指令和行为特定描述的框架方便理解

### 宿主和设备的环境要求

略

### 执行模型

Vulkan会暴露一个或多个设备，每个设备暴露一个或多个队列(queue)，每个队列异步执行处理工作。一个设备支持的一组队列用家族(Family)区分。每个家族支持一种或多种类型的功能，并且可能包含多个具有相似特点的队列。

单个家族中的多个队列被视为互相兼容的，并且对于一个队列的家族来说，工作的产出可以在其中任意一个队列中执行。这种特性决定了队列可能支持下列类型的功能：图像，计算，视频解码，视频编码，受保护的内存管理，稀疏内存管理和传输。

**注意**:

单个设备可能会报告多个相似的队列家族，同时也会报告这些家族的多个成员。这表示虽然这些家族有相似的功能，但是这些家族之间不能直接兼容。

设备的内存是被应用显式管理的。每个设备可能通知一个或多个代表了不同内存区域的堆。内存堆可以是设备本地的或者宿主本地的，但是对于设备来说都总是可见的。关于内存堆的额外细节是通过可用的内存类型暴露的。关于可用内存区，举例来说包括如下:

- 设备本地(device-local):与设备物理上直接相连的内存
- 设备本地，宿主可见(device-local, host visible): 就是宿主能够访问的设备本地内存
- 宿主本地:，宿主可见(host-local,host visible): 宿主本地内存，并且可被宿主和设备访问

### 队列的操作

Vulkan的队列为设备的执行引擎提供了接口，这些执行引擎的指令，在执行时间之前，被记录于指令缓冲(command buffer)中，然后把指令提交到某个队列中执行。一旦指令被提交到队列，指令缓冲会在不需应用干预的情况下开始和完成这次执行。然而，执行的顺序依赖于[多个显式或隐式的顺序约束](https://docs.vulkan.org/spec/latest/chapters/synchronization.html#synchronization)

提交到队列的工作，是用队列提交指令完成，这个指令会取形如vkQueue*(比如 vkQueueSubmit, vkQueueBindSparse),也可以取一组用于在工作前等待的信号量，和一组用于在工作完成后的信号量。

工作本身，也包括发信号和等待信号，全都是队列来操作的。一旦队列操作被提交，队列提交指令会把控制权交回给应用，不用等待指令完成。

> 指令通过指令缓冲记录，使用指令提交命令来把指令提交给队列。指令的执行顺序取决于一个约束规则，指令的执行是异步的，指令的异步执行过程都由队列控制。指令一旦提交完成，就会自动执行，同时控制权交回给应用，应用不需要等待指令执行完成。

指令缓冲的提交到某个队列遵守[提交顺序](https://docs.vulkan.org/spec/latest/chapters/synchronization.html#synchronization-submission-order)和其他[隐式顺序保障](https://docs.vulkan.org/spec/latest/chapters/synchronization.html#synchronization-implicit)。但是别的方式可能部分同时或不遵守这个顺序。依赖单个队列的，带有其他队列提交或批指令的其他类型的批命令和队列提交(比如 稀疏内存绑定)没有隐式的顺序约束。在队列提交和各个批处理之间额外的显式顺序约束可以用信号量或栅栏来表示

> 只有指令缓冲的提交队列操作是严格遵守规则的，但是其他类型的指令可能不遵守，可以用信号量或栅栏完成执行顺序的约束

在栅栏或信号量被通知之前，可以保证之前提交到队列的操作都完成了执行，并且哪些队列操作写入的内存是可以被之后的队列操作使用的。等待被通知的信号量或栅栏的方式，保证了之前的内存写入时可用的，并且同时对后续的指令是可见的

指令缓冲的边界，在相同或不同批指令或提交指令的主指令缓冲之间，或者在主和次指令缓冲之间，都不会引入任何额外的顺序约束。换句话说，在任何信号量或栅栏之间提交一组指令缓冲(包括对次要指令缓冲的执行)来执行指令，被视作是单个主要指令缓冲中执行指令，但每个边界处的当前状态会被重置。显式顺序约束可以用显式同步原语表示

> 次级指令缓冲依附于主指令缓冲，主要用途是分解和模块化复杂的指令，并使其可复用。
> 指令缓冲之间是没有顺序的，提交的指令都可视作单个主指令缓冲里执行的，只是会把当前状态设为reset。若要控制顺序，可用同步原语，详见文档原文

在指令缓冲中记录的指令可执行多种动作，指令的属性包括:

- Action: 可更新内存里的值，比如绘制(draw)指令，分派(dispatch)指令
- State: 状态设置指令可更新当前指令缓冲的状态，会影响后续指令的动作
- synchronization: 同步指令引入了[显式的执行和内存依赖](https://docs.vulkan.org/spec/latest/chapters/synchronization.html#synchronization-dependencies)对动作指令做出影响
- indirection： 间接指令执行其他指令，这些指令没有直接记录于同一个指令缓冲中

**注意**:

在缺乏显式同步机制或隐式顺序保障的情况下，动作指令可能同步执行或者不按顺序执行，可能造成数据竞争。然而这种执行顺序不会影响动作指令所观察到的当前状态。每个动作指令只会根据进入指令缓冲那一刻的状态，不会根据其执行时的状态。

> 在不保证执行顺序的场景下，要注意数据竞争问题。动作型的指令只会参考进入到缓冲时那一刻的状态，不会参考它自己在执行时那一刻的状态

### 对象模型

设备，队列，和其他Vulkan里的实体是用Vulkan对象表示的。所有对象的引用是用句柄。有两种类型的句柄，可分派和不可分派的。可分派的句柄是一个指向不透明类型的指针。这种指针可能被layers(层)作为切入API的指令使用，因此，每个API指令都会把可分派的类型作为第一个参考。每个可分派类型的对象，在整个生命周期内必须有一个独立的句柄值

不可分派的句柄的类型，是一个64位整数，这意味着此类型的句柄依赖于具体实现。若某个VkDevice对象的privateData特性被启用，在这个设备上创建的不可分派类型对象必须拥有一个生命周期内独立的句柄值。否则，不可分派句柄可能把对象的信息直接编码到句柄里，而不是看作某个相关对象的引用，这样做可能句柄就没有独立的值了。若句柄值不是独立的，那么销毁这种句柄必定不会导致同种类型的句柄变为不可用，并且若此句柄值被创建次数多余销毁次数，那么必定不会造成同种类型的对象变为不可用。

所有从VkDevice创建或分配的对象，都是在这个设备上私有的，不能被其他设备使用

> Vulkan使用对象表示各种事物的抽象，这些对象通过句柄来引用，句柄有两种：可分派和不可分派的，可分派句柄一般被层使用，用来对API做切入，可分派的句柄值需要保证唯一性
> 不可分派的句柄要注意，若值不唯一，可能导致对象的创建，销毁等操作出问题

#### 对象的生命周期

对象的创建和分配通过vkCreate*和vkAllocate*命令完成。一旦对象被创建或分配完成，这个对象的结构体大部分就被视作不可变的。对象的销毁或释放通过vkDestroy*和vkFree*命令完成

分配出来的对象是从已有的池对象或者内存堆里获取所需的资源，当被释放时，会把这部分资源返回给池或者堆里。对象的创建和销毁一般来讲被期望是低频并行的，分配和释放操作发生的频率较高。池对象帮助优化分配和释放的性能

应用自己负责跟踪Vulkan对象的生命周期，并且这些对象还在使用时，不要销毁它们

当有任何Vulkan的指令传入时，应用拥有的内存的所属权会立即交出给vulkan。这些内存的所属权，除非指令被延后了，应该在指令结束期间必须被交还给应用。以便应用可以及时修改或释放这部分内存。若指令被延后了，会在延后的指令完成时把所属权交还。

> 某些类型的对象要注意不能随便销毁，某些类型会在指令传入后不可访问，详见原文档

