# 内存管理，内存对齐，内存分配器

简明扼要，通俗易懂

## 内存的物理结构

1. 内存条上的黑色矩形小片片，一个片就叫做一个chip
2. chip里面又由多个bank组成，这些bank可以看成一组，叫做bank group，在DDR4及以后的内存条，1个chip可能有多个bank group,每个bank group里面又有多个bank
3. bank里面可以看成n x m个格子组成的方块，其中的格子就叫做cell，一个cell代表1bit，是由电容实现，这个cell就可通过行和列(row, column)来定位到，cell也是内存中能管理的最小单位
4. $内存条的容量 = 每个bank里cell总数 * bank数量 * bankgroup数量 $
5. 由于CPU和内存之间的数据，一般来说位宽是64bit，由于单个chip的位宽一般没那么大(比如4/8/16bit)需要把多个chip组合起来，并行存取才能达到64bit的要求，rank就是指要几个chip达到64bit的要求，用64bit除以chip的位宽就可得到一个rank对应几个chip
6. 内存条上来说，1rank就代表这个内存条是单面的，每面有几个chip，是用64bit除以chip位宽得到，2rank就是正反两面都有chip
7. DIMM就是内存模组的意思，就是指一种结构，这种结构的内存条印刷电路板正反面均有金手指与主板上的内存条槽接触。一个DIMM至少有1个RANK
8. 同一个RANK的chip，连接到一个CS(Chip Select)信号线上，方便对这些chip同时读写64bit的数据

> 此处只对关键信息做了筛选和精炼，若需更详尽的资料，可参考文末的参考资料

## CPU与内存间的交互过程

1. CPU通过内存控制器进行内存的读写操作，早期是在北桥芯片里，为了减少延迟，现在大部分都集成在CPU内部
2. 民用CPU一般有两个内存控制器，每个内存控制器有一个CHANNEL(DDR5的有两个CHANNEL),每个CHANNEL的带宽位64bit(DDR5的是32bit),有几个CHANNEL就叫做几通道，服务器CPU可能有更多的内存控制器和CHANNEL
3. 由于CPU一般一次性就操作64bit数据，双通道场景下，不是一次性操作128bit数据，而是一次用一个通道，另一个通道先准备好下一份数据，交错进行，这样可以提高数据处理性能
4. 一个CHANNEL可操作多个DIMM
5. 为了提高存取性能，CPU向内存请求数据时，不是只请求64bit, 而是一个cache line的大小(L1~L3缓存位宽的大小一般是64bit * 8 = 64 byte)，请求一个cache line的操作，叫做Burst IO。多出来的数据，会放到这三级高速缓存里面，所以利用好缓存，提高缓存命中率，就可减少访存操作，进而提高性能，使用到的数据，放入寄存器中

## 内存对齐

### 为什么要内存对齐

#### 硬件层面的解释

由于内存是按照chip并行访问的，每个chip分别存了几个bit，若内存对齐，不仅chip的内存地址偏移量是相同的，而且可以一次性存取数据

如果内存没对齐，一次操作就取不完整，而且每个chip的地址偏移量也不一样，由于发送偏移量的总线宽度大概是40bit(64位)，而且只有一条总线，就意味着一次访存操作只能读取一个结果。

两种解决方法也不行：

- `增加到8根总线，支持传8个偏移量`： 会导致CPU针脚要增加几百个，会大大提升硬件复杂程度，而且总线多了以后，由于内存访问信号频率非常高，干扰也会变大
- `由于非对齐访问实际也就两个偏移量，而且偏移量是连续的，可以在内存里加一根额外的线，实现同时访问offset和offset+1的数据`： 这样做会导致内存控制芯片要加一个额外的加法器(支持把offset加1的操作)，所有内存读写都需要加一个计算的操作，会降低内存时钟

另外，由于高速缓存和这个偏移量是关联的，不同的偏移量数据被不同cache line缓存，那么非对齐的数据也会导致多次cache的读取，也会降低效率

#### 软件层面的解释

1. 要提高CPU从内存存取数据的性能
2. 要兼容不同的系统和CPU
3. 要支持特定指令集，如SIMD
4. 要对内存使用进行跟踪和统计

对于非对齐的内存数据，不同的CPU行为不同，对对齐的要求也不同

非对齐的数据，有些CPU可以访问, 有些CPU不能访问，能访问的情况下，有些CPU会降低性能,有些不会,此处不详述，可查阅文末参考资料

所以统一做内存对齐，有助于提高性能和兼容性，代价是浪费一些内存空间, 因为要做内存的对齐填充

### 如何内存对齐

1. 基础类型的对齐值就是其大小，即sizeof等于alignof
2. struct/class/union类型里，每个非静态成员都要对齐，对齐值是这些成员里，alignof后最大的那个值
3. 若手动设置了对齐值，就要与2里的这个值比较，若手动设置的值更小，就按这个值对齐，反之按第2里的值对齐
4. 成员对齐后，整个struct/class/union也要对齐，按3里确定后的值的整数倍对齐，多余出来的空间做填充
5. 若对象是嵌套的场景，同上

#### 手动设置对齐值的方法

1. 用#pragma pack: 需要是2的次方倍(如1，2，4，8)，默认为8
2. 用编译器的/Zp参数：等效于#pragma pack(如/Zp8等效于#pragma pack(8))

### 例子

- 使用alignof(A)获取某个类型A的对齐值
- 使用sizeof(A)获取某个类型A的占用空间大小
- 使用offsetof(A,a)获取某个类型A的成员a的偏移量
- 使用#pragma pack()设置数据打包时对齐字节数，一般用来压缩数据占用的空间，要小于对象里成员中最大的alignof值才有效
- 使用alignas()指定一个类型的对齐字节数

```c++
#include <cstdlib>
#include <iostream>

// 默认对齐
struct A {
 char a;// size:1, align:1, offset:0
 char* b;//size:8, align:8, offset:8
 int c; // size:4, align:4, offset:16
 double d; // size:8, align:8, offset:24
}; // alignof: 8, sizeof: 32

// 按2byte对齐
#pragma pack(2)
struct B {
 char a;// size:1, align:1, offset:0
 char* b;//size:8, align:8, offset:2
 int c; // size:4, align:4, offset:10
 double d; // size:8, align:8, offset:14
}; // alignof: 2, sizeof: 22

// 恢复默认对齐,不写的话还是2
#pragma pack()
// 测试pack大于最大align成员的场景
// 测试后发现，pack必须小于成员里最大alignof的值才有效，大于此值无效
// #pragma pack(16)
struct C {
 void* ptr; // size:8, align:8, offset:0
 A struct_a; // size: 32, align: 8, offset: 8√
 B struct_b; // size: 22, align: 2, offset: 40√ 注意还是按照2来对齐的
}; // alignof: 8√, sizeof: 62√

// windows10, 64位，visual studio 2022
int main() {
 // A
 std::cout << "A.a: alignof: "
  << alignof(char) << " sizeof: "
  << sizeof(char) << " offsetof: "
  << offsetof(A, a)
  << std::endl;
 std::cout << "A.b: alignof: "
  << alignof(char*) << " sizeof: "
  << sizeof(char*) << " offsetof: "
  << offsetof(A, b)
  << std::endl;
 std::cout << "A.c: alignof: "
  << alignof(int) << " sizeof: "
  << sizeof(int) << " offsetof: "
  << offsetof(A, c)
  << std::endl;
 std::cout << "A.d: alignof: "
  << alignof(double) << " sizeof: "
  << sizeof(double) << " offsetof: "
  << offsetof(A, d)
  << std::endl;
 std::cout << "A: alignof: "
  << alignof(A) << " sizeof: "
  << sizeof(A)
  << std::endl;
 // ==================================
 std::cout << std::endl;
 // B
 std::cout << "B.a: alignof: "
  << alignof(char) << " sizeof: "
  << sizeof(char) << " offsetof: "
  << offsetof(B, a)
  << std::endl;
 std::cout << "B.b: alignof: "
  << alignof(char*) << " sizeof: "
  << sizeof(char*) << " offsetof: "
  << offsetof(B, b)
  << std::endl;
 std::cout << "B.c: alignof: "
  << alignof(int) << " sizeof: "
  << sizeof(int) << " offsetof: "
  << offsetof(B, c)
  << std::endl;
 std::cout << "B.d: alignof: "
  << alignof(double) << " sizeof: "
  << sizeof(double) << " offsetof: "
  << offsetof(B, d)
  << std::endl;
 std::cout << "B: alignof: "
  << alignof(B) << " sizeof: "
  << sizeof(B)
  << std::endl;
 // ==================================
 std::cout << std::endl;
 // C
 std::cout << "C.ptr: alignof: "
  << alignof(void*) << " sizeof: "
  << sizeof(void*) << " offsetof: "
  << offsetof(C, ptr)
  << std::endl;
 std::cout << "C.struct_a: alignof: "
  << alignof(A) << " sizeof: "
  << sizeof(A) << " offsetof: "
  << offsetof(C, struct_a)
  << std::endl;
 std::cout << "C.struct_b: alignof: "
  << alignof(B) << " sizeof: "
  << sizeof(B) << " offsetof: "
  << offsetof(C, struct_b)
  << std::endl;
 std::cout << "C: alignof: "
  << alignof(C) << " sizeof: "
  << sizeof(C)
  << std::endl;
}
```

结果是:

```c++
A.a: alignof: 1 sizeof: 1 offsetof: 0
A.b: alignof: 8 sizeof: 8 offsetof: 8
A.c: alignof: 4 sizeof: 4 offsetof: 16
A.d: alignof: 8 sizeof: 8 offsetof: 24
A: alignof: 8 sizeof: 32

B.a: alignof: 1 sizeof: 1 offsetof: 0
B.b: alignof: 8 sizeof: 8 offsetof: 2
B.c: alignof: 4 sizeof: 4 offsetof: 10
B.d: alignof: 8 sizeof: 8 offsetof: 14
B: alignof: 2 sizeof: 22

C.ptr: alignof: 8 sizeof: 8 offsetof: 0
C.struct_a: alignof: 8 sizeof: 32 offsetof: 8
C.struct_b: alignof: 2 sizeof: 22 offsetof: 40
C: alignof: 8 sizeof: 64
```

## 编译器

编译器不会自动优化内存对齐，关于内存对齐，只有C++标准里规定了每个基础类型的对齐值就是其大小

## 操作系统

## 参考资料

### 内存物理结构

1. [内存内部结构](https://cloud.tencent.com/developer/article/2418503)
2. [内存物理结构](https://segmentfault.com/a/1190000045071118)
3. [DDR介绍](https://blog.csdn.net/u013372900/article/details/121155029)
4. [硬件层面解释内存为什么要对齐](https://yangwang.hk/?p=773)

### 内存管理

1. [ZJUFish: 深入C++内存管理](https://blog.csdn.net/ZJU_fish1996/article/details/108858577)
2. [killerAery: 内存管理](https://www.cnblogs.com/KillerAery/p/10765893.html)
3. [木头骨头石头: 内存管理](https://zhuanlan.zhihu.com/p/463216948)
4. [star.E: 内存管理](https://zhuanlan.zhihu.com/p/96089089)