= 第五章 类和类的层次结构

== C.1 把相关的数据组织到struct或class中

比如一个函数具有多个入参，可以把参数封装成可读性更好的struct或class，同时参数数量也更少

== C.2 若类具有不变式，则用class，反之，则用struct

是关于如何选择struct还是class的方法，就根据参数之间是否可以独立变化，若可以则struct，反之则class

不变式个人理解： 无规矩不成方圆，有恒定规矩的事物，因其规矩才成为一体，相关的元素放在class，否则放在struct

通俗来讲，struct里的元素可以独立变化互不影响，只是把他们绑在一起而已，而class里的元素，它们之间可能有某些固定不变的规则才使其成为一种事物

== C.3 在类中体现出接口和实现的区别

类的public成员函数应该是类的接口，而实现应该放在private里，这样，不会影响此类的用户

== C.4 仅当函数需要直接访问类的内部时，才把其变成成员

也就是如何判断一个函数是否应该是成员函数的办法，就是看这个函数是否要直接访问到类的内部数据，好处是松耦合

== C.5 将辅助函数与它们所支持的类放在同一个namespace中

== C.7 不要在一条语句里同时定义和声明该类型的变量

如 struct A{...} a{...}; 应该避免,分成两条写，防止疑惑

== C.8 若有任何private成员，就用class而不是struct

因为需要构造函数来保证不变式，故应使用class更好

== C.9 尽量减少成员的暴露

不用多说

== C.10 优先使用具体类型而不是类层次

更简单，性能开销小，具体类型就是指单个具体的类，即值类型的类

== C.11 让具体类型规范化

规范类型： 类似int，必须支持拷贝，赋值，相等比较，可交换，析构，移动，默认构造操作

主要是易于理解和使用

== C.20 如果能避免定义拷贝，移动，析构函数，那就这么做

是说如果类的成员都支持移动，拷贝构造，阿么就尽量不要自己写这个类的移动，拷贝构造等函数

== C.21 如果delete了任意拷贝，移动，析构函数，就对所有这些函数都手动定义或delete

就是只要出现delete了任意一种构造,析构函数，就需要显式将其他几种函数都default或手动定义

== C.22 让拷贝，移动，析构函数的操作保持一致

防止类的用户产生疑惑

== C.45 不要定义只用来初始化成员的默认构造函数，而是用成员初始化器替代

就是在默认构造函数里给成员赋默认值，这么做不好，改成在成员写上默认值(用大括号)，然后默认构造器保持default

这样更容易维护构造器的逻辑，如果以后修改或添加新的成员，不用每次都更改默认构造函数的逻辑

== C.46 单参数的构造函数声明为explicit

不用多说

== C.47 按照成员声明的顺序定义和初始化成员列表

要注意，类的成员的实际初始化顺序取决于声明的顺序，而不是初始化列表的顺序,析构则是按声明顺序相反的顺序进行

== C.48 初始化常量时，优先使用类内初始化器，而不是构造函数成员初始化

就是类的成员，能用类似于int s{50};这样的初始化就用，优先于构造函数的成员初始化

== C.49 构造函数里优先使用初始化，而不是赋值

不用多说

== C.51 使用委托构造函数来表示所有构造函数里共同的操作

在构造函数里的初始化列表调用这个公用的构造函数，利于维护

== C.52 使用继承构造函数来把基类的构造函数导入到不需要进一步显式初始化的派生类里

在派生类中, using Base::Base;即为把基类的构造函数导入到派生类里，这样不用重写构造函数，很新鲜，之前还不知道

== C.67 多态类应该抑制公开的拷贝/移动操作

这个不懂，后续再看

== C.30 如果一个类在销毁时需要明确的操作，就定义析构函数

不用多说

== C.31 类获得的资源都必须在该类的析构函数中释放

不用多说

== C.33 如果类有具有所有权的指针成员，请定义析构函数

这个条款简单明了

== C.35 基类的析构函数要么是public virtual,要么是protected且非virtual

这个挺重要的，我在其它源码见到，这里写道:

* 如果基类析构函数为private，则无法从此类派生
* 如果基类析构函数为protected, 则可以从该类派生，但只能使用自类

我还记得如果析构函数私有可以让此类无法在栈上分配！需要确认！

== C.80 如果你需要明确使用默认语意，则用=default

一般是结合五法则，如果有任何一个构造函数定义了，就需要定义其他构造函数，如果这些其他的构造函数没有特别的操作，就写=default

要主要default的规则和具体操作，我之前看过，但是不是特别牢靠，需要在后续补充

== C.81 当想要禁用默认行为时，使用=delete

与C80相似，不用多说

== C.82 不要在构造函数和析构函数中调用虚函数

在构造函数或析构函数中调用纯虚函数，是未定义行为，故处于安全考虑，实际是调用的非虚版本的函数

我也没那么写过，不过值得注意

== C.86 使 == 对操作数的类型对称，并使其noexcept

有点意思，但是一眼没看懂，之后再看

== C.87 当心基类上的 ==

后面看

== C.120 仅使用类的层次结构来表达具有内在层次结构的概念

设计类的层次结构时，确保这个层次结构与实际场景一致

比如有个基类包含了众多纯虚函数，但是派生类实际只关心其中一部分纯虚函数，这样就不好

== C.121 如果基类被当作接口使用，那就把它变成抽象类

就是带有纯虚函数的类，这种类不能被实例化，也通常没有数据成员

之前看到有ABI保障时，提到最好不要用虚函数，我记得是陈硕的某个工程实践里写过，到时候回去结合看看

== C.122 当需要完全分离接口和实现时，以抽象类作为接口

同上

== C.126 抽象类通常不需要构造函数

一般抽象类不要有数据成员，因此不需要构造函数

== C.128 虚函数应该指定virtual, override, final三者之一

简单明了

== C.130 若要对多态类进行深拷贝，应使用虚函数clone, 而不是公开的拷贝构造/赋值

之后再看

== C.132 不要无缘无故把函数变为virtual

虚函数是有代价的:

. 增加运行时间和对象的大小
. 由于可以在派生类中被覆盖，更容易出问题

== C.131 避免无价值的get/set函数

可考虑变为public，并把这些值放到一个struct里，这个确实与java不同，一般来说java的类会有很多get/set

== C.133 避免protected数据

会使程序变得复杂且容易出错，当类层次变得复杂的时候，protected的数据到底谁初始化，谁在用就变得不清不楚了，就如同一种全局数据。

== C.134 确保所有非const的数据成员都具有相同的访问级别

属于不变式的为private，不属于的为public，尽量少用protected

== C.129 在设计类的层次结构时，要区分实现继承和接口继承

嗯，挺重要的，有点长，之后看

== C.135 使用多重继承来表示多个不同接口

这个挺常见的，也就是注意接口专一性，然后再用一个大接口去继承这几个专一的接口

== C.138 使用using 为派生类及其基类创建重载集

之后看

== C.140 不要为虚函数和它的覆盖函数提供不同的默认参数

容易产生混乱，同一个函数可能由于覆盖导致不同的结果

== C.146 在跨类层次不可避免时，使用dynamic_cast

== C.147 当不允许找不到所需的类时，要对引用类型使用dynamic_cast

== C.148 当允许找不到所需的类时，要对指针类型使用dynamic_cast

== C.152 永远不要把指向派生类对象指针的数据赋值给指向基类的指针

上面几个是一个系列的，用的少，之后看

== C.167 应当对带有常规含义的操作使用运算符

没什么说的

== C.161 对于对称的运算符，应采用非成员函数

好的，后续看看具体怎么说的

== C.164 避免隐式转换运算符

不用多说

== C.162 重载的代价应当大致等价

== C.163 仅对大致等价的操作进行重载

以上两条就是说，等价的操作应当具有相同的名字，不等价的就不要写成同一个名字
比如：

[source,c++]
----
// 大致等价
void print(int a);
void print(const std::string& str);
// 不等价，不推荐这样起名
std::string translate(const std::string& text);
Code translate(const Code& code);
----

== C.168 在操作数所在的命名空间中定义重载操作符

一眼没看懂，之后看

== C.180 使用union来节省内存

== C.181 避免裸union

== C.182 使用匿名union来实现带标签的联合体

union这几条之后看，因为对这个东西还不太熟


