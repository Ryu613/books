= 第六章 标准模板库

====
本章开始才真正开始介绍STL

用法一定要结合cppreference网站看，二者一定程度可互补，重复的部分相当于加强印象

本章倾向于先讲整体性，普遍性的内容，算是一个引入，具体看后续章节

某些名词术语与我之前学到的不同，但基本不影响理解

写的函数详细的，并且展开有度，更深入具体的放在后面的章节，组织较好
====

== 重点

. 容器三大类型: 有序容器， 有序关联容器， 无序关联容器
. 有序容器, 基础用法已知，略，按照另一本{cpp}23 std作者rainer grimm来说，95%场景使用vector即可，少数高性能场景考虑array,其他的类型性能差距太大，少用，vector关键在于用好resize和reserve减少内存分配次数即可提高性能
.. std::array:没有内存动态分配，最快，但是容量固定，不太灵活
.. std::vector: 容量可缩放，但是缩放的代价就是内存分配造成性能损耗(可通过reserve/resize改善，绝大部分场景推荐使用)
.. std::deque: 双端队列,头尾增删迅速
.. std::list, std::forward_list 分别是双向链表和单向链表，插入速度快，随机访问(O(n))慢vector(O(1))太多，往容器元素中间插入理论上比vector快一些(vector往中间插入要移动元素，有性能开销)，forward_list只有指向下一个元素的指针，比起list占内存小一些，不用维护两个指针，性能好一些，但是倒序迭代原生不支持
. 关联式容器,基础用法略， 注意multi版本，元素可重复，这些重复元素的排列顺序在11以后是根据插入顺序确定，先插入的排前面，保证了次序:
.. std::set
.. std::multiset
.. std::map
.. std::multimap
. 无序关联容器: 无序查找元素理论上比有序快，只要哈希函数较好
.. std::unordered_set
.. std::unordered_multiset
.. std::unordered_map
.. std::unordered_multimap
. 容器适配器：满足特殊需求，从基本容器派生出来
.. std::stack 先进后出
.. std::queue 先进先出
.. std::priority_queue 带优先级的队列，根据优先级决定下一个元素是谁的先进先出队列
. 迭代器: 已知，略
. 算法
.. 范围算法：处理容器内一个区间范围内的元素，注意是半开的，即[begin, end)
. 迭代器适配器: 特殊用途迭代器
.. insert iterator: 要迭代并插入元素用， 根据要在最前，最后还是中间插入，区分
... back_inserter: 末尾插入,需要目标容器提供push_back()才行
... front_inserter: 开端插入， 需要目标容器提供push_front()
... inserter: 通用插入，根据第一个参数决定怎么插入, 第二个参数是插入的值，调用目标容器的insert()
.. stream iterator: 输入输出的流式处理时用
.. reverse iterator: 倒序迭代，需要容器支持双向或者随机迭代器才行，比如forward_list就不支持
.. move iterator: 有移动操作迭代用，比如从一个容器把元素完全"搬到"另外一个容器(原容器元素一旦搬出就没了)
. 非只读算法(书里叫manipulating algorithm(中文叫更易型算法))
.. std::remove: 在容器指定一个区间内的范围进行移除，注意会造成元素移动，删除的元素的后一个往前移，并且容器的总大小不变,末尾的元素不变！返回一个指向remove后最后一个元素的iterator
... 可以在删除操作后，获取到被删除元素的数量，因为remove返回的iterator和end()的iterator可取差即可得
... 可把remove返回的iterator当作新的终点，根据自己的需求继续操作
... 要真正删除(符合直觉的那种)，应该用erase(),比如可在remove后用erase(end, coll.end());
... 为什么设计得那么反直觉: 为了灵活度，迭代器与容器本身是分离的，不关心内部元素
. 用算法还是具体容器的函数，取决于你是否有跨容器操作的需求，一般来讲，容器的函数性能好
. 允许把函数作为参数的算法
.. std::for_each: 容器区间内遍历时，可带对每个元素的操作，传入的函数可以不带返回值，可对原容器元素修改
.. std::transform: 对容器内某个区间的元素进行转换，一般不修改原容器，传入的函数要带返回值，创建新容器
... 语义上，虽然二者有重合，但是可以说：for_each强调要用这些元素做什么,包括对自己，transform强调要对元素本身做出修改，一般不做其他操作
.. 判断式 就是返回布尔值的,分为一元谓词和二元谓词(就是要判断出布尔需要提供几个参数，二元一般就是比较两个值大小时候用)

== 待探讨

. 函数对象部分暂时略过


