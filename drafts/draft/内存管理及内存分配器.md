# 内存管理，内存对齐，内存分配器

简明扼要，通俗易懂

## 内存的物理结构

1. 内存条上的黑色矩形小片片，一个片就叫做一个chip
2. chip里面又由多个bank组成，这些bank可以看成一组，叫做bank group，在DDR4及以后的内存条，1个chip可能有多个bank group,每个bank group里面又有多个bank
3. bank里面可以看成n x m个格子组成的方块，其中的格子就叫做cell，一个cell代表1bit，是由电容实现，这个cell就可通过行和列(row, column)来定位到，cell也是内存中能管理的最小单位
4. $内存条的容量 = 每个bank里cell总数 * bank数量 * bankgroup数量 $
5. 由于CPU和内存之间的数据，一般来说位宽是64bit，由于单个chip的位宽一般没那么大(比如4/8/16bit)需要把多个chip组合起来，并行存取才能达到64bit的要求，rank就是指要几个chip达到64bit的要求，用64bit除以chip的位宽就可得到一个rank对应几个chip
6. 内存条上来说，1rank就代表这个内存条是单面的，每面有几个chip，是用64bit除以chip位宽得到，2rank就是正反两面都有chip
7. DIMM就是内存模组的意思，就是指一种结构，这种结构的内存条印刷电路板正反面均有金手指与主板上的内存条槽接触。一个DIMM至少有1个RANK
8. 同一个RANK的chip，连接到一个CS(Chip Select)信号线上，方便对这些chip同时读写64bit的数据

> 此处只对关键信息做了筛选和精炼，若需更详尽深入的资料，比如内存协议，排线设计，管线原理，可参考文末的参考资料

## CPU与内存间的交互过程

1. CPU通过内存控制器进行内存的读写操作，早期是在北桥芯片里，为了减少延迟，现在大部分都集成在CPU内部
2. 民用CPU一般有两个内存控制器，每个内存控制器有一个CHANNEL(DDR5的有两个CHANNEL),每个CHANNEL的带宽位64bit(DDR5的是32bit),有几个CHANNEL就叫做几通道，服务器CPU可能有更多的内存控制器和CHANNEL
3. 由于CPU一般一次性就操作64bit数据，双通道场景下，不是一次性操作128bit数据，而是一次用一个通道，另一个通道先准备好下一份数据，交错进行，这样可以提高数据处理性能
4. 一个CHANNEL可操作多个DIMM
5. 为了提高存取性能，CPU向内存请求数据时，不是只请求64bit, 而是一个cache line的大小(L1~L3缓存位宽的大小一般是64bit * 8 = 64 byte)，请求一个cache line的操作，叫做Burst IO。多出来的数据，会放到这三级高速缓存里面，所以利用好缓存，提高缓存命中率，就可减少访存操作，进而提高性能，使用到的数据，放入寄存器中
6. 内存数据不是直接存到CPU寄存器中的，而是会先存到多级缓存中，若CPU需要某些数据，会先到高速缓存中查看是否存在，若不存在，才会从内存请求数据，并放到缓存中
7. 当CPU需要写入数据时，有两种方式:
   - 写入到缓存时，同时写入内存
   - 只写入到缓存，有必要时才写入内存

> 内存对齐，紧凑，连续，使访问局部性提高，有助于性能的提升

## 内存对齐

### 为什么要内存对齐

#### 硬件层面的解释

由于内存是按照chip并行访问的，每个chip分别存了几个bit，若内存对齐，不仅chip的内存地址偏移量是相同的，而且可以一次性存取数据

如果内存没对齐，一次操作就取不完整，而且每个chip的地址偏移量也不一样，由于发送偏移量的总线宽度大概是40bit(64位)，而且只有一条总线，就意味着一次访存操作只能读取一个结果。

两种解决方法也不行：

- `增加到8根总线，支持传8个偏移量`： 会导致CPU针脚要增加几百个，会大大提升硬件复杂程度，而且总线多了以后，由于内存访问信号频率非常高，干扰也会变大
- `由于非对齐访问实际也就两个偏移量，而且偏移量是连续的，可以在内存里加一根额外的线，实现同时访问offset和offset+1的数据`： 这样做会导致内存控制芯片要加一个额外的加法器(支持把offset加1的操作)，所有内存读写都需要加一个计算的操作，会降低内存时钟

另外，由于高速缓存和这个偏移量是关联的，不同的偏移量数据被不同cache line缓存，那么非对齐的数据也会导致多次cache的读取，也会降低效率

#### 软件层面的解释

1. 要提高CPU从内存存取数据的性能
2. 要兼容不同的系统和CPU
3. 要支持特定指令集，如SIMD
4. 要对内存使用进行跟踪和统计，如cache line， 偏移等

对于非对齐的内存数据，不同的CPU行为不同，对对齐的要求也不同

非对齐的数据，有些CPU可以访问, 有些CPU不能访问，能访问的情况下，有些CPU会降低性能,有些不会,此处不详述，可查阅文末参考资料

所以统一做内存对齐，有助于提高性能和兼容性，代价是浪费一些内存空间, 因为要做内存的对齐填充

### 如何内存对齐

1. 基础类型的对齐值就是其大小，即sizeof等于alignof
2. struct/class/union类型里，每个非静态成员都要对齐，对齐值是这些成员里，alignof后最大的那个值
3. 若手动设置了对齐值，就要与2里的这个值比较，若手动设置的值更小，就按这个值对齐，反之按第2里的值对齐
4. 成员对齐后，整个struct/class/union也要对齐，按3里确定后的值的整数倍对齐，多余出来的空间做填充
5. 若对象是嵌套的场景，同上

#### 手动设置对齐值的方法

1. 用#pragma pack: 需要是2的次方倍(如1，2，4，8)，默认为8
2. 用编译器的/Zp参数：等效于#pragma pack(如/Zp8等效于#pragma pack(8))
3. 在类型前面加alignas(), C++17支持
4. 使用std::aligned_storage<sizeof(XXX), 16>::type buffer;分配以n对齐的栈内存，并通过reinterpret_cast强转类型指针, C++17支持
5. 使用std::aligned_alloc(16, sizeof(XXX))分配首地址对齐n字节的堆内存，C++17

### 例子

- 使用alignof(A)获取某个类型A的对齐值
- 使用sizeof(A)获取某个类型A的占用空间大小
- 使用offsetof(A,a)获取某个类型A的成员a的偏移量
- 使用#pragma pack()设置数据打包时对齐字节数，一般用来压缩数据占用的空间，要小于对象里成员中最大的alignof值才有效
- 使用alignas()指定一个类型的对齐字节数

```c++
#include <cstdlib>
#include <iostream>

// 默认对齐
struct A {
 char a;// size:1, align:1, offset:0
 char* b;//size:8, align:8, offset:8
 int c; // size:4, align:4, offset:16
 double d; // size:8, align:8, offset:24
}; // alignof: 8, sizeof: 32

// 按2byte对齐
#pragma pack(2)
struct B {
 char a;// size:1, align:1, offset:0
 char* b;//size:8, align:8, offset:2
 int c; // size:4, align:4, offset:10
 double d; // size:8, align:8, offset:14
}; // alignof: 2, sizeof: 22

// 恢复默认对齐,不写的话还是2
#pragma pack()
// 测试pack大于最大align成员的场景
// 测试后发现，pack必须小于成员里最大alignof的值才有效，大于此值无效
// #pragma pack(16)
struct C {
 void* ptr; // size:8, align:8, offset:0
 A struct_a; // size: 32, align: 8, offset: 8√
 B struct_b; // size: 22, align: 2, offset: 40√ 注意还是按照2来对齐的
}; // alignof: 8√, sizeof: 62√

// windows10, 64位，visual studio 2022
int main() {
 // A
 std::cout << "A.a: alignof: "
  << alignof(char) << " sizeof: "
  << sizeof(char) << " offsetof: "
  << offsetof(A, a)
  << std::endl;
 std::cout << "A.b: alignof: "
  << alignof(char*) << " sizeof: "
  << sizeof(char*) << " offsetof: "
  << offsetof(A, b)
  << std::endl;
 std::cout << "A.c: alignof: "
  << alignof(int) << " sizeof: "
  << sizeof(int) << " offsetof: "
  << offsetof(A, c)
  << std::endl;
 std::cout << "A.d: alignof: "
  << alignof(double) << " sizeof: "
  << sizeof(double) << " offsetof: "
  << offsetof(A, d)
  << std::endl;
 std::cout << "A: alignof: "
  << alignof(A) << " sizeof: "
  << sizeof(A)
  << std::endl;
 // ==================================
 std::cout << std::endl;
 // B
 std::cout << "B.a: alignof: "
  << alignof(char) << " sizeof: "
  << sizeof(char) << " offsetof: "
  << offsetof(B, a)
  << std::endl;
 std::cout << "B.b: alignof: "
  << alignof(char*) << " sizeof: "
  << sizeof(char*) << " offsetof: "
  << offsetof(B, b)
  << std::endl;
 std::cout << "B.c: alignof: "
  << alignof(int) << " sizeof: "
  << sizeof(int) << " offsetof: "
  << offsetof(B, c)
  << std::endl;
 std::cout << "B.d: alignof: "
  << alignof(double) << " sizeof: "
  << sizeof(double) << " offsetof: "
  << offsetof(B, d)
  << std::endl;
 std::cout << "B: alignof: "
  << alignof(B) << " sizeof: "
  << sizeof(B)
  << std::endl;
 // ==================================
 std::cout << std::endl;
 // C
 std::cout << "C.ptr: alignof: "
  << alignof(void*) << " sizeof: "
  << sizeof(void*) << " offsetof: "
  << offsetof(C, ptr)
  << std::endl;
 std::cout << "C.struct_a: alignof: "
  << alignof(A) << " sizeof: "
  << sizeof(A) << " offsetof: "
  << offsetof(C, struct_a)
  << std::endl;
 std::cout << "C.struct_b: alignof: "
  << alignof(B) << " sizeof: "
  << sizeof(B) << " offsetof: "
  << offsetof(C, struct_b)
  << std::endl;
 std::cout << "C: alignof: "
  << alignof(C) << " sizeof: "
  << sizeof(C)
  << std::endl;
}
```

结果是:

```c++
A.a: alignof: 1 sizeof: 1 offsetof: 0
A.b: alignof: 8 sizeof: 8 offsetof: 8
A.c: alignof: 4 sizeof: 4 offsetof: 16
A.d: alignof: 8 sizeof: 8 offsetof: 24
A: alignof: 8 sizeof: 32

B.a: alignof: 1 sizeof: 1 offsetof: 0
B.b: alignof: 8 sizeof: 8 offsetof: 2
B.c: alignof: 4 sizeof: 4 offsetof: 10
B.d: alignof: 8 sizeof: 8 offsetof: 14
B: alignof: 2 sizeof: 22

C.ptr: alignof: 8 sizeof: 8 offsetof: 0
C.struct_a: alignof: 8 sizeof: 32 offsetof: 8
C.struct_b: alignof: 2 sizeof: 22 offsetof: 40
C: alignof: 8 sizeof: 64
```

#### 注意

1. 编译器不会自动优化内存对齐，关于内存对齐，只有C++标准里规定了每个基础类型的对齐值就是其大小

## 内存管理

### C++中的内存布局

1. 可把C++的内存分布看作一个矩形，横向切多刀分成多段，从上至下依次是：
   - `内核空间`: 防止操作系统相关的代码和数据，用户不能直接操作，只能通过操作系统提供的api操作
   - `栈(Stack)`：先进先出的栈结构，数据紧凑连续，存放代码块里的局部变量，函数参数值，返回值等。内存地址从高到低增长，程序初始化时由编译器自动分配大小，一般为1-8M
   - `未分配空间`: 保留给相邻的两个区
   - `内存映射段`: 文件映射，动态库，匿名映射
   - `未分配空间`: 保留给相邻的两个区
   - `堆(Heap)`: 代码里动态分配的数据，数据分布不保证紧凑连续，需要手动释放，按需对齐，比如new，malloc等一般就是在此区分配，内存地址从低到高增长
   - `BSS(block started by symbol)`: 存放未初始化的全局和静态变量
   - `数据段(data segment)`: 存放初始化完成的全局和静态变量，常量数据值
   - `代码段(code segment)`: 存放可执行程序的机器码
2. 一般情况下，栈空间少于对空间，当调用函数时，这个函数相关的数据(比如函数的返回地址，局部变量，CPU寄存器数据)会把函数压入栈顶(压栈)，函数返回时，从栈弹出
3. 栈帧就是即将要压栈的待运行函数的数据，每调用一次函数会创建一个栈帧，函数完毕后，栈帧就会被销毁
4. 简化后的内存布局，可看为:(从上到下(从高到低)): 栈，堆，全局区，常量区，代码区，其中堆的容量一般最大 
5. 分配方式：
   - 栈： 一般分配速度很快，程序员一般无法控制，局部变量是静态分配的，在编译阶段分配完成，其他需要在运行时才能确定如何分配的，叫动态分配
   - 堆： 一般分配速度相对较慢，在运行时按需动态分配

### CPU指令集和操作系统

1. 图像一个像素点的信息量可能只有8bit，而CPU的寄存器带宽可能是32位及以上，一次只处理一个数据浪费了带宽，所以比如若寄存器带宽是64bit，处理8bit像素信息，能并行处理8个，就可提高处理效率
2. 若CPU支持SSE指令，则寄存器是128bit的，比如一个浮点数是4byte(32bit),那么可以同时运算4个浮点数计算
3. 系统并不是直接使用内存地址，而是会把这个地址映射到虚拟地址上,这样从应用程序的角度上来看，虽然物理内存快地址可能不连续，但是虚拟内存地址就是连续的，一般来说虚拟内存大于物理内存空间
4. 虚拟内存中，每个程序拥有的地址空间被划分为多个块，每个块就叫做一页，每个块里包含了连续的地址。当一个虚拟的页没有对应的物理内存时，叫做缺页，这时操作系统会从硬盘把数据加载到内存里，同时，当内存不足时，部分页的数据也会写回硬盘，腾出内存空间
   - 所以尽量减少缺页发生，在一个较小的页范围内处理数据，即保持局部性，就可提高性能
5. 虚拟内存中叫页，对应物理内存中就叫页框，二者大小一致，硬盘根内存之间的数据交换就是以页为单位的，由MMU做地址映射。虚拟页对应的页框会记录到页表里，页表是放在内存中的，包含了虚拟页号和偏移量，虚拟页号就对应了页框号，再通过偏移量对页框偏移，就可得到物理内存地址。为了优化页表，提升数据交换效率，这个页表可能有不同的结构，比如分级页表，倒排页表等，因为页表在内存中，为了加快访问，会有一个缓冲叫TLB

### C++的内存分配

#### placement new

实际上就是new操作符的一个重载，可指定在哪块内存构造类型，主要用于把内存的分配和构造两个过程分离，因为分配过程是比较耗时的，所以向自己控制对象的分配和释放，以提高性能

例子:

```c++
class A
{
private:
 int data;
public:
 A(int indata) 
  : data(indata) { }
 void print()
 {
  cout << data << endl;
 }
};
int main()
{
 const int size = 10;
 // 用char的原因是方便控制大小(char就是1byte),而且不希望像对象那样，进行自动构造
 char buf[size * sizeof(A)]; // 在栈上分配了10个A大小的char数组
 for (size_t i = 0; i < size; i++)
 {
  new (buf + i * sizeof(A)) A(i); // 在buf这个栈里面，构造i个A
 }
 // 把buf看作A类型的指针
 A* arr = (A*)buf;
 for (size_t i = 0; i < size; i++)
 {
  arr[i].print();
  arr[i].~A(); // 对象析构
 }
 // 栈上预分配的内存自动释放
 return 0;
```

C++17还支持带对齐的new,也支持在类型前面用alignas声明对齐字节数

#### malloc

1. 只分配虚拟内存空间，而不是物理内存空间，只有当这些虚拟内存空间首次访问时，才会分配真正的物理内存空间,这是操作系统的“写时分配”行为导致的
2. 在分配时，会有一个内存大小信息写入到header数据中，实际分配的内存大小会大于请求的内存，也就是说，若分配的空间越小，由于header的存在，会导致空间利用上比较低效(header数据占的比例大)
3. malloc可以保证返回的内存首地址时自动对齐的(windows 64一般是8字节，linux64一般是16字节)
4. malloc不一定会调用系统的内存分配api
   - 首先，看自己的内存池有没有可重用的空闲内存，若没有，才会调用系统的内存分配api
   - 若用户需要分配的内存小于128k(具体看操作系统)，会通过brk()申请内存，根据分配的大小把堆顶指针往上移一定的位置，并把这个移动后的内存块地址返回
   - 当free掉之前分配的内存时，并不会直接返还给操作系统，而是缓存在malloc可分配的内存中，以便下次使用
   - 如果用户分配的内存大于128kb,则通过系统mmap()申请内存，建立匿名映射来获取虚拟内存
   - 当free掉之前分配的内存时，调用munmap()把内存归还给操作系统，即内存会被真正释放
5. malloc是用全局锁实现的线程安全，所以多线程频繁调用的话，会造成更明显的性能下降

#### 内存分配策略

- `内存池`： 预先分配一大块连续内存，一般叫做arena，制定好再分配和释放方法，当需要申请小块内存时(称为block)，可以向这个内存池请求，不用再次分配
  - 由于内存池一般较大，所以释放其本身不容易产生内存碎片，同时内存池大小固定，即便内部出现内存泄漏或碎片问题，也不会导致内存泄漏超过内存池，把问题扩大

##### 栈式分配器

只有一个指向栈顶的指针，在里面申请内存时只移动这个指针

适合临时的小对象，小字符串使用

- 优点：高效，只往后移动指针，不管内存的释放，没有内存碎片
- 缺点：内存空间利用率低，因为内存越分配占用越多，没有单个的释放操作(除非整个内存池释放)

可应用于堆，栈，或静态区，使用在后两者时，可避免malloc调用

注意：缓冲区的生命周期最好大于或等于分配器的生命周期

例子如下:

```c++
class StackAllocator{
public:
  //传入一个在栈上/静态存储区上的缓冲区地址及其尺寸信息
  StackAllocator(void* buffer, uint32_t size_bytes);
  //不做任何操作
  ~StackAllocator();
  //从顶端指针分配一个新的内存块，并将顶端指针移上相应的位移大小。
  void* alloc(uint32_t size_bytes);
  //不做任何操作
  void deallocate(void*);
  //重置顶端指针为 0
  void clear();
private:
  uint32_t top;    //顶端指针
  uint32_t size;   //缓冲区尺寸
  void* buffer;    //缓冲区
};

void test()
{
    char buffer[255];
    StackAllocator allocator(buffer, 255);
    // do something with allocator...
}
```

##### 单帧内存分配器

基于栈式分配器，只是可以用完后通过把指针移动到内存起始位置来清理内存。适合用于只在当前帧内有效的临时对象

##### 双缓冲内存分配器

包含两个栈式分配器，一般用于包含两帧数据的场景

#### 可回收内存的分配器

以上的内存分配做不到单个内存块的释放，只能清空整个内存池。空闲链表法就可以解决此问题。

空闲链表在在释放时，会把钥匙放的内存块添加到一个链表上，代表空闲的内存块

分配时，会先从空闲链表的开头处取得空闲的内存块，如果没有，则上移顶端指针，从顶端指针处分配一个新的对象内存块

实现时尽量不用容器(会占用更多额外内存)，而是在需要释放的内存块上写一些header信息，冰河链表的头节点link上

例子:

```c++
// 相当于header信息
struct FreeListNode
{
    FreeListNode* next;  //指向下一个空闲内存块的首地址， 64位下占8字节
    uint32_t size;  //表示当前空闲内存块的尺寸， 占4字节
}; // 按8字节对齐，故大小为16字节

class FreeListAllocator
{
    //...
private:
    //...
    FreeListNode* freeList;  //空闲链表头结点
}
```

为了回收内存后进行碎片整理，并保证外部的指针不会空悬，一般会引入一层重定向指针，当某个内存块整理碎片后挪到了另一个地址上，就会让这个重定向指针指向新的地址，这样外部指针地址就不变

在碎片整理时，要对内存块进行复制和移动，开销比较大，为了避免卡顿(一次性整理太多碎片)，可以将整理过程分解成多次，平摊给每帧

此分配器适用于小的对象分配上，一般不超过数千字节

##### 自动垃圾回收思路

1. 批量化：一次性处理多个请求，比如可在耗时较短的单帧结束时统一GC
2. 延迟化：可把分配和释放设计为commit，分配器只在合适的时间点才进行真正的操作

#### 对象池

把同种类型的对象放到一起，方便处理时使缓存更容易命中，提升性能，DOP的设计理念就是如此而来

例子如下:

```c++
template<class T>
class ObjectPool{
public:
  //先从freeList队首取得空闲内存块；
  //若无空闲内存块，则上移顶端指针，并从顶端指针处分配出一个新的对象内存块。
  T* allocate();
  //将释放的内存块添加到freeList
  void deallocate(T* ptr);
  // ...
private:
  uint32_t top;      //顶端指针索引
  FreeListNode* freeList;  //空闲链表，其包含了各个已释放的块
  uint32_t size;     //内存池尺寸
  T* pool;     //内存池
};
```

优点：

- 每次分配/释放的内存大小相同，无需考虑内存碎片(新分配的对象由于大小一致，可直接插到释放的空间里)
- 更容易缓存命中，由于数据连续，缓存相邻的地址都是存同种数据，减少从内存或外存中存取的次数

大量分配同一类型对象时使用

释放策略除了之前提到的空闲链表，懒删除法，还可以把尾部对象移动到释放的内存块上：

优点： 数据连续，紧凑，cache友好
缺点： 破坏排序，指针地址变动

#### 等尺寸类型的分配器

可将不同类型的对象，根据类型大小，统一看成一个类型，减少各种类型池的数量

这个分配器内部根据对象的大小分为若干个内存池，比如8位的，16位的，32位等，这样就可以满足大部分类型的内存需求，大尺寸内存池的可以放入小的对象，但是会被对齐填充

可基于对象池的优缺点来看

优点： 使用场景广，减少了对象池根据类型划分为过多数量的问题
缺点： 对cache相对每对象池友好，因为对象之间的相关性可能不高

##### 优化

可把此分配器划分为若干组，如动画组，物理组，每个组有自己的分配器，分配内存时，手动指定属于哪个组，从而让此分配器的对象具有更好的关联性

一种不需要额外分组参数的办法是HALO, 此处不赘述
解决空闲列表法分配内存不能过小的办法是可考虑使用bitmap,此处不赘述

#### 伙伴分配器

#### slab分配器

### 内存分配器的实现

## 参考资料

### 内存物理结构相关

1. [内存内部结构](https://cloud.tencent.com/developer/article/2418503)
2. [内存物理结构](https://segmentfault.com/a/1190000045071118)
3. [DDR介绍](https://blog.csdn.net/u013372900/article/details/121155029)
4. [硬件层面解释内存为什么要对齐](https://yangwang.hk/?p=773)

### 内存管理相关

1. [ZJUFish: 深入C++内存管理](https://blog.csdn.net/ZJU_fish1996/article/details/108858577)
2. [killerAery: 内存管理](https://www.cnblogs.com/KillerAery/p/10765893.html)
3. [木头骨头石头: 内存管理](https://zhuanlan.zhihu.com/p/463216948)
4. [star.E: 内存管理](https://zhuanlan.zhihu.com/p/96089089)
5. [函数栈帧](https://blog.csdn.net/qq_41412237/article/details/119489211)
6. [C++内存精讲](https://www.cnblogs.com/hornets/p/12461380.html)

### 内存分配器实现相关